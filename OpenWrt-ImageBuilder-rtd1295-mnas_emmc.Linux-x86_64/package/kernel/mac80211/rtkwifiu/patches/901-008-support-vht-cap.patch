--- a/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/include/rtw_wifi_regd.h
@@ -22,5 +22,9 @@ enum country_code_type_t {
 int rtw_regd_init(_adapter *padapter);
 void rtw_reg_notify_by_driver(_adapter *adapter);
 
+#ifdef CONFIG_80211AC_VHT
+extern const u16 VHT_MCS_DATA_RATE[3][2][30];
+#endif
+
 #endif /* __RTW_WIFI_REGD_H__ */
 
--- a/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/ioctl_cfg80211.c
@@ -6286,12 +6286,111 @@ static void rtw_cfg80211_init_ht_capab(_
 	
 }
 
+#ifdef CONFIG_80211AC_VHT
+static void rtw_cfg80211_init_vht_capab(_adapter *padapter, struct ieee80211_sta_vht_cap *vht_cap, enum ieee80211_band band, u8 rf_type)
+{
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct mlme_priv        *pmlmepriv = &padapter->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	u8      bw;
+	u16     HighestRate;
+	u8 *pcap, *pcap_mcs;
+	
+	rtw_vht_use_default_setting(padapter);
+	
+	vht_cap->vht_supported = _TRUE;
+	pcap = &vht_cap->cap;
+	
+	SET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(pcap, 2);
+	SET_VHT_CAPABILITY_ELE_CHL_WIDTH(pcap, 0);  //indicate we don't support neither 160M nor 80+80M bandwidth.
+	// B4 Rx LDPC
+	if(TEST_FLAG(pvhtpriv->ldpc_cap, LDPC_VHT_ENABLE_RX))
+	{
+			SET_VHT_CAPABILITY_ELE_RX_LDPC(pcap, 1);
+	}
+	
+	// B5 ShortGI for 80MHz
+	SET_VHT_CAPABILITY_ELE_SHORT_GI80M(pcap, pvhtpriv->sgi_80m? 1 : 0); // We can receive Short GI of 80M
+	
+	// B6 ShortGI for 160MHz
+	//SET_VHT_CAPABILITY_ELE_SHORT_GI160M(pcap, pvhtpriv->sgi_80m? 1 : 0);
+	
+	// B7 Tx STBC
+	if(TEST_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_TX))
+	{
+			SET_VHT_CAPABILITY_ELE_TX_STBC(pcap, 1);
+	}
+	// B8 B9 B10 Rx STBC
+	if(TEST_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_RX))
+	{
+			if ((rf_type == RF_2T2R) || (rf_type == RF_1T2R)) {
+					SET_VHT_CAPABILITY_ELE_RX_STBC(pcap, 1);
+			}
+			else if (rf_type == RF_1T1R) {
+					SET_VHT_CAPABILITY_ELE_RX_STBC(pcap, 1);
+			}
+	}
+	
+	// B11 SU Beamformer Capable
+	if(TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE))
+	{
+			SET_VHT_CAPABILITY_ELE_SU_BFER(pcap, 1);
+			// B16 17 18 Number of Sounding Dimensions
+			SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(pcap, 1);
+	}
+	
+	// B12 SU Beamformee Capable
+	if(TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE))
+	{
+			SET_VHT_CAPABILITY_ELE_SU_BFEE(pcap, 1);
+			// B13 14 15 Compressed Steering Number of Beamformer Antennas Supported
+			SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(pcap, 1);
+	}
+	
+	// B19 MU Beamformer Capable
+	SET_VHT_CAPABILITY_ELE_MU_BFER(pcap, 0);  //HW don't support mu bfee/bfer
+	// B20 MU Beamformee Capable
+	SET_VHT_CAPABILITY_ELE_MU_BFEE(pcap, 0);
+	// B21 VHT TXOP PS
+	SET_VHT_CAPABILITY_ELE_TXOP_PS(pcap, 0);
+	// B22 +HTC-VHT Capable
+	SET_VHT_CAPABILITY_ELE_HTC_VHT(pcap, 1);
+	// B23 24 25 Maximum A-MPDU Length Exponent
+	if (pregistrypriv->ampdu_factor != 0xFE)
+	{
+			SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pcap, pregistrypriv->ampdu_factor);
+	}
+	else
+	{
+			SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pcap, 7);
+	}
+	// B26 27 VHT Link Adaptation Capable
+	SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(pcap, 0);
+	
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_RX_MCS(pcap);
+	_rtw_memcpy(pcap_mcs, pvhtpriv->vht_mcs_map, 2);
+	
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_TX_MCS(pcap);
+	_rtw_memcpy(pcap_mcs, pvhtpriv->vht_mcs_map, 2);
+	
+	bw = (pregistrypriv->bw_mode >> 4);
+	HighestRate = VHT_MCS_DATA_RATE[bw][pvhtpriv->sgi_80m][((pvhtpriv->vht_highest_rate - MGN_VHT1SS_MCS0)&0x3f)];
+	HighestRate = (HighestRate+1) >> 1;
+	
+	SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(pcap, HighestRate); //indicate we support highest rx rate is 600Mbps.
+	SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(pcap, HighestRate); //indicate we support highest tx rate is 600Mbps.
+}
+#endif
+
 void rtw_cfg80211_init_wiphy(_adapter *padapter)
 {
 	u8 rf_type;
 	struct ieee80211_supported_band *bands;
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
 	struct wiphy *wiphy = pwdev->wiphy;
+#ifdef CONFIG_80211AC_VHT
+	struct registry_priv    *pregistrypriv = &padapter->registrypriv;
+#endif
 	
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
@@ -6305,8 +6404,13 @@ void rtw_cfg80211_init_wiphy(_adapter *p
 #ifdef CONFIG_IEEE80211_BAND_5GHZ
 	if (IsSupported5G(padapter->registrypriv.wireless_mode)) {	
 		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
-		if(bands)
+		if(bands) {
 			rtw_cfg80211_init_ht_capab(padapter, &bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
+			#ifdef CONFIG_80211AC_VHT
+			if (pregistrypriv->vht_enable)
+				rtw_cfg80211_init_vht_capab(padapter, &bands->vht_cap, IEEE80211_BAND_5GHZ, rf_type);
+			#endif
+		}
 	}
 #endif
 	/* init regulary domain */
--- a/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/realtek/rtkwifiu/rtl8811au/os_dep/linux/os_intfs.c
@@ -130,7 +130,7 @@ int rtw_beamform_cap = 0x2;
 /*
  * DHCWIFI-73: Enable 11AC products GO/Soft-AP default VHT80. rtw_vht_enable = 2
  */
-int rtw_vht_enable = 2; //0:disable, 1:enable, 2:force auto enable
+int rtw_vht_enable = 1; //0:disable, 1:enable, 2:force auto enable
 int rtw_ampdu_factor = 7;
 int rtw_vht_rate_sel = 0;
 #endif //CONFIG_80211AC_VHT
