//-----------------------------------------------------------
// BDROMCommonTypes.h
// Copyright (c) 2003, Sonic Solutions.  All rights reserved.
// This code was generated by BitPackerGenerator.
//-----------------------------------------------------------

#ifndef _BDROMCommonTypes_h_
#define _BDROMCommonTypes_h_

#include "BitPacker.h"

#if defined(_WIN32)
#pragma warning(push)
#pragma warning(disable:4100)	//	unreferenced formal param
#endif
	
namespace BDROM { 
struct ext_data_entry : public bitpacker::BitPacker {
  bitpacker::uint mID1;
  bitpacker::uint mID2;
  bitpacker::uint mext_data_start_address;
  bitpacker::uint mext_data_length;

  ext_data_entry();
  ext_data_entry(const ext_data_entry& _a);
  explicit 
  ext_data_entry(const char* _a);
  ext_data_entry(rt_stream& _a);
  virtual ~ext_data_entry() {}
  void layout(size_t = 0);
  void init();
  void copy(const ext_data_entry& _a);
  ext_data_entry& operator=(const ext_data_entry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ExtensionData : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mdata_block_start_address;
  const bitpacker::reserved m_padding0;
  bitpacker::uint mnumber_of_ext_data_entries;
  bitpacker::array<ext_data_entry> mext_data_entries;
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = mdata_block_start_address ? mdata_block_start_address - byteOffset(&mpad1) : 0;
  			return mpad1_size;
  		}
  	
  size_t  mdata_block_size;
  bitpacker::array<bitpacker::uint> mdata_block;

  		size_t & db_size(void)
  		{
  			mdata_block_size = mlength + 4 - mdata_block_start_address;
  			return mdata_block_size;
  		}
  	

  ExtensionData();
  ExtensionData(const ExtensionData& _a);
  explicit 
  ExtensionData(const char* _a);
  ExtensionData(rt_stream& _a);
  virtual ~ExtensionData() {}
  void layout(size_t = 0);
  void init();
  void copy(const ExtensionData& _a);
  ExtensionData& operator=(const ExtensionData& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct UO_mask_table : public bitpacker::BitPacker {
  const bitpacker::reserved m_padding1;
  const bitpacker::reserved m_padding2;
  bitpacker::bits mchapter_search_mask;
  bitpacker::bits mtime_search_mask;
  bitpacker::bits mskip_to_next_point_mask;
  bitpacker::bits mskip_back_to_previous_point_mask;
  const bitpacker::reserved m_padding3;
  bitpacker::bits mstop_mask;
  bitpacker::bits mpause_on_mask;
  const bitpacker::reserved m_padding4;
  bitpacker::bits mstill_off_mask;
  bitpacker::bits mforward_play_mask;
  bitpacker::bits mbackward_play_mask;
  bitpacker::bits mresume_mask;
  bitpacker::bits mmove_up_selected_button_mask;
  bitpacker::bits mmove_down_selected_button_mask;
  bitpacker::bits mmove_left_selected_button_mask;
  bitpacker::bits mmove_right_selected_button_mask;
  bitpacker::bits mselect_button_mask;
  bitpacker::bits mactivate_button_mask;
  bitpacker::bits mselect_and_activate_mask;
  bitpacker::bits mprimary_audio_stream_number_change_mask;
  const bitpacker::reserved m_padding5;
  bitpacker::bits mangle_number_change_mask;
  bitpacker::bits mpopup_on_mask;
  bitpacker::bits mpopup_off_mask;
  bitpacker::bits mPG_textST_enable_disable_mask;
  bitpacker::bits mPG_textST_stream_number_change_mask;
  bitpacker::bits msecondary_video_enable_disable_mask;
  bitpacker::bits msecondary_video_stream_number_change_mask;
  bitpacker::bits msecondary_audio_enable_disable_mask;
  bitpacker::bits msecondary_audio_stream_number_change_mask;
  const bitpacker::reserved m_padding6;
  bitpacker::bits mPiP_PG_textST_stream_number_change_mask;
  const bitpacker::reserved m_padding7;

  	void SetAll(int mask);
  	void SetFrom(unsigned char * uops);
  	void GetAsArray(unsigned char * uops);
  	void Combine(const UO_mask_table & uoTable);
  	

  UO_mask_table();
  UO_mask_table(const UO_mask_table& _a);
  explicit 
  UO_mask_table(const char* _a);
  UO_mask_table(rt_stream& _a);
  virtual ~UO_mask_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const UO_mask_table& _a);
  UO_mask_table& operator=(const UO_mask_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

}
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ext_data_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ExtensionData& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::UO_mask_table& _a);
#endif

#if defined(_WIN32)
#pragma warning(pop)
#endif

#endif // _BDROMCommonTypes_h_

