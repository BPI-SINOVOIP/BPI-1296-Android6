//-----------------------------------------------------------
// BDROMPlaylist.h
// Copyright (c) 2003, Sonic Solutions.  All rights reserved.
// This code was generated by BitPackerGenerator.
//-----------------------------------------------------------

#ifndef _BDROMPlaylist_h_
#define _BDROMPlaylist_h_

#include "BitPacker.h"

#if defined(_WIN32)
#pragma warning(push)
#pragma warning(disable:4100)	//	unreferenced formal param
#endif
	
#include "BDROMCommonTypes.h"
namespace BDROM { 
struct PlayListMark : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mnumber_of_PlayListMarks;
  struct PlayListMarkItem : public bitpacker::BitPacker {
    const bitpacker::reserved m_padding8;
    bitpacker::uint mmark_type;
    bitpacker::uint mref_to_PlayItem_id;
    bitpacker::uint mmark_time_stamp;
    bitpacker::uint mentry_ES_PID;
    bitpacker::uint mduration;

    PlayListMarkItem();
    PlayListMarkItem(const PlayListMarkItem& _a);
    explicit 
    PlayListMarkItem(const char* _a);
    PlayListMarkItem(rt_stream& _a);
    virtual ~PlayListMarkItem() {}
    void layout(size_t = 0);
    void init();
    void copy(const PlayListMarkItem& _a);
    PlayListMarkItem& operator=(const PlayListMarkItem& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize) {}
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  bitpacker::array<PlayListMarkItem> mPlayListMarkItem;

  PlayListMark();
  PlayListMark(const PlayListMark& _a);
  explicit 
  PlayListMark(const char* _a);
  PlayListMark(rt_stream& _a);
  virtual ~PlayListMark() {}
  void layout(size_t = 0);
  void init();
  void copy(const PlayListMark& _a);
  PlayListMark& operator=(const PlayListMark& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct multi_clip_entries : public bitpacker::BitPacker {
  bitpacker::uint mnumber_of_Clip_entries;
  const bitpacker::reserved m_padding9;
  struct subClip_entry : public bitpacker::BitPacker {
    bitpacker::str mClip_information_file_name;
    bitpacker::str mClip_codec_identifier;
    bitpacker::uint mref_to_STC_id;

    subClip_entry();
    subClip_entry(const subClip_entry& _a);
    explicit 
    subClip_entry(const char* _a);
    subClip_entry(rt_stream& _a);
    virtual ~subClip_entry() {}
    void layout(size_t = 0);
    void init();
    void copy(const subClip_entry& _a);
    subClip_entry& operator=(const subClip_entry& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize) {}
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  size_t  msubClip_entry_size;
  bitpacker::array<subClip_entry> msubClip_entry;

  	    size_t & subClip_entry_size(void)   {
  	        msubClip_entry_size = mnumber_of_Clip_entries - 1;
  	        return msubClip_entry_size;
  	    }
  	

  multi_clip_entries();
  multi_clip_entries(const multi_clip_entries& _a);
  explicit 
  multi_clip_entries(const char* _a);
  multi_clip_entries(rt_stream& _a);
  virtual ~multi_clip_entries() {}
  void layout(size_t = 0);
  void init();
  void copy(const multi_clip_entries& _a);
  multi_clip_entries& operator=(const multi_clip_entries& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct SubPlayItem : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::str mClip_information_file_name;
  bitpacker::str mClip_codec_identifier;
  const bitpacker::reserved m_padding10;
  bitpacker::bits msp_connection_condition;
  bitpacker::bits mis_multi_Clip_entries;
  bitpacker::uint mref_to_STC_id;
  bitpacker::uint mSubPlayItem_IN_time;
  bitpacker::uint mSubPlayItem_OUT_time;
  bitpacker::uint msync_PlayItem_id;
  bitpacker::uint msync_start_PTS_of_PlayItem;
  multi_clip_entries mmulti_clip_entries;

  SubPlayItem();
  SubPlayItem(const SubPlayItem& _a);
  explicit 
  SubPlayItem(const char* _a);
  SubPlayItem(rt_stream& _a);
  virtual ~SubPlayItem() {}
  void layout(size_t = 0);
  void init();
  void copy(const SubPlayItem& _a);
  SubPlayItem& operator=(const SubPlayItem& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct SubPath : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding11;
  bitpacker::uint mSubPath_type;
  const bitpacker::reserved m_padding12;
  bitpacker::bits mis_repeat_SubPath;
  const bitpacker::reserved m_padding13;
  bitpacker::uint mnumber_of_SubPlayItems;
  bitpacker::array<SubPlayItem> mSubPlayItem;

  SubPath();
  SubPath(const SubPath& _a);
  explicit 
  SubPath(const char* _a);
  SubPath(rt_stream& _a);
  virtual ~SubPath() {}
  void layout(size_t = 0);
  void init();
  void copy(const SubPath& _a);
  SubPath& operator=(const SubPath& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct multi_angle_clip_entries : public bitpacker::BitPacker {
  bitpacker::uint mnumber_of_angles;
  const bitpacker::reserved m_padding14;
  bitpacker::bits mis_different_audios;
  bitpacker::bits mis_seamless_angle_change;
  struct angle_clip_entry : public bitpacker::BitPacker {
    bitpacker::str mClip_information_file_name;
    bitpacker::str mClip_codec_identifier;
    bitpacker::uint mref_to_STC_id;

    angle_clip_entry();
    angle_clip_entry(const angle_clip_entry& _a);
    explicit 
    angle_clip_entry(const char* _a);
    angle_clip_entry(rt_stream& _a);
    virtual ~angle_clip_entry() {}
    void layout(size_t = 0);
    void init();
    void copy(const angle_clip_entry& _a);
    angle_clip_entry& operator=(const angle_clip_entry& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize) {}
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  size_t  mangles_size;
  bitpacker::array<angle_clip_entry> mangle_entry;

  	    size_t & angles_size(void)  {
  	        mangles_size = mnumber_of_angles-1;
  	        return mangles_size;
  	    }
  	

  multi_angle_clip_entries();
  multi_angle_clip_entries(const multi_angle_clip_entries& _a);
  explicit 
  multi_angle_clip_entries(const char* _a);
  multi_angle_clip_entries(rt_stream& _a);
  virtual ~multi_angle_clip_entries() {}
  void layout(size_t = 0);
  void init();
  void copy(const multi_angle_clip_entries& _a);
  multi_angle_clip_entries& operator=(const multi_angle_clip_entries& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct stream_entry : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mstream_entry_type;
  bitpacker::uint mref_to_stream_PID_of_mainClip_t1;
  bitpacker::bits64 mreserved_for_future_use_1;
  bitpacker::uint mref_to_SubPath_id_t2;
  bitpacker::uint mref_to_subClip_entry_id_t2;
  bitpacker::uint mref_to_stream_PID_of_subClip_t2;
  bitpacker::bits mreserved_for_future_use_2;
  bitpacker::uint mref_to_SubPath_id_t3;
  bitpacker::uint mref_to_stream_PID_of_mainClip_t3;
  bitpacker::bits64 mreserved_for_future_use_3;

  		inline UInt32 get_ref_to_stream_PID_of_Clip(void)
  		{
  			if (mstream_entry_type == 1)
  				return mref_to_stream_PID_of_mainClip_t1;
  			else if (mstream_entry_type == 2)
  				return mref_to_stream_PID_of_subClip_t2;
  			else if (mstream_entry_type == 3)
  				return mref_to_stream_PID_of_mainClip_t3;
  			else
  				return 0x1FFF;		// null packet PID
  		}

  		inline UInt32 get_ref_to_SubPath_id(void)
  		{
  			if (mstream_entry_type == 2)
  				return mref_to_SubPath_id_t2;
  			else if (mstream_entry_type == 3)
  				return mref_to_SubPath_id_t3;
  			else
  				return 0xFFFF;		// id not available
  		}

  		inline UInt32 get_ref_to_subClip_entry_id(void)
  		{
  			if (mstream_entry_type == 2)
  				return mref_to_subClip_entry_id_t2;
  			else
  				return 0xFFFF;		// id not available
  		}
  	

  stream_entry();
  stream_entry(const stream_entry& _a);
  explicit 
  stream_entry(const char* _a);
  stream_entry(rt_stream& _a);
  virtual ~stream_entry() {}
  void layout(size_t = 0);
  void init();
  void copy(const stream_entry& _a);
  stream_entry& operator=(const stream_entry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct stream_attributes : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mstream_coding_type;
  bitpacker::bits mvideo_format;
  bitpacker::bits mframe_rate;
  bitpacker::bits mreserved_for_future_use2;
  bitpacker::bits mreserved_for_future_use2b;

  		UInt32 bdrom_ver(void) const;
  	
  bitpacker::bits maudio_presentation_type;
  bitpacker::bits msampling_frequency;
  bitpacker::str maudio_language_code;
  bitpacker::str mPG_language_code;
  bitpacker::bits mreserved_for_future_use3;
  bitpacker::str mIG_language_code;
  bitpacker::bits mreserved_for_future_use4;
  bitpacker::uint mcharacter_code;
  bitpacker::str mtextST_language_code;

  stream_attributes();
  stream_attributes(const stream_attributes& _a);
  explicit 
  stream_attributes(const char* _a);
  stream_attributes(rt_stream& _a);
  virtual ~stream_attributes() {}
  void layout(size_t = 0);
  void init();
  void copy(const stream_attributes& _a);
  stream_attributes& operator=(const stream_attributes& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct stream_entries : public bitpacker::BitPacker {
  stream_entry mstream_entry;
  stream_attributes mstream_attributes;

  stream_entries();
  stream_entries(const stream_entries& _a);
  explicit 
  stream_entries(const char* _a);
  stream_entries(rt_stream& _a);
  virtual ~stream_entries() {}
  void layout(size_t = 0);
  void init();
  void copy(const stream_entries& _a);
  stream_entries& operator=(const stream_entries& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct secondary_audio_stream_entries : public bitpacker::BitPacker {
  stream_entry mstream_entry;
  stream_attributes mstream_attributes;
  bitpacker::uint mnumber_of_primary_audio_ref_entries;
  const bitpacker::reserved m_padding15;
  bitpacker::array<bitpacker::uint> mprimary_audio_stream_id_ref;
  bitpacker::bits mreserved_pad1;

  secondary_audio_stream_entries();
  secondary_audio_stream_entries(const secondary_audio_stream_entries& _a);
  explicit 
  secondary_audio_stream_entries(const char* _a);
  secondary_audio_stream_entries(rt_stream& _a);
  virtual ~secondary_audio_stream_entries() {}
  void layout(size_t = 0);
  void init();
  void copy(const secondary_audio_stream_entries& _a);
  secondary_audio_stream_entries& operator=(const secondary_audio_stream_entries& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct secondary_video_stream_entries : public bitpacker::BitPacker {
  stream_entry mstream_entry;
  stream_attributes mstream_attributes;
  bitpacker::uint mnumber_of_secondary_audio_ref_entries;
  const bitpacker::reserved m_padding16;
  bitpacker::array<bitpacker::uint> msecondary_audio_stream_id_ref;
  bitpacker::bits mreserved_pad1;
  bitpacker::uint mnumber_of_PiP_PG_textST_ref_entries;
  const bitpacker::reserved m_padding17;
  bitpacker::array<bitpacker::uint> mPiP_PG_textST_stream_id_ref;
  bitpacker::bits mreserved_pad2;

  secondary_video_stream_entries();
  secondary_video_stream_entries(const secondary_video_stream_entries& _a);
  explicit 
  secondary_video_stream_entries(const char* _a);
  secondary_video_stream_entries(rt_stream& _a);
  virtual ~secondary_video_stream_entries() {}
  void layout(size_t = 0);
  void init();
  void copy(const secondary_video_stream_entries& _a);
  secondary_video_stream_entries& operator=(const secondary_video_stream_entries& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct STN_table : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding18;
  bitpacker::uint mnumber_of_primary_video_stream_entries;
  bitpacker::uint mnumber_of_primary_audio_stream_entries;
  bitpacker::uint mnumber_of_PG_textST_stream_entries;
  bitpacker::uint mnumber_of_IG_stream_entries;
  bitpacker::uint mnumber_of_secondary_audio_stream_entries;
  bitpacker::uint mnumber_of_secondary_video_stream_entries;
  bitpacker::uint mnumber_of_PiP_PG_textST_stream_entries_plus;
  const bitpacker::reserved m_padding19;
  bitpacker::array<stream_entries> mprimary_video_stream_entries;
  bitpacker::array<stream_entries> mprimary_audio_stream_entries;
  bitpacker::array<stream_entries> mPG_textST_stream_entries;
  size_t  mnum_pg_strms;

  		size_t & num_pgs(void)
  		{
  			mnum_pg_strms = mnumber_of_PG_textST_stream_entries + mnumber_of_PiP_PG_textST_stream_entries_plus;
  			return mnum_pg_strms;
  		}
  	
  bitpacker::array<stream_entries> mIG_stream_entries;
  bitpacker::array<secondary_audio_stream_entries> msecondary_audio_stream_entries;
  bitpacker::array<secondary_video_stream_entries> msecondary_video_stream_entries;

  STN_table();
  STN_table(const STN_table& _a);
  explicit 
  STN_table(const char* _a);
  STN_table(rt_stream& _a);
  virtual ~STN_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const STN_table& _a);
  STN_table& operator=(const STN_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct PlayItem : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::str mClip_information_file_name;
  bitpacker::str mClip_codec_identifier;
  const bitpacker::reserved m_padding20;
  bitpacker::bits mis_multi_angle;
  bitpacker::bits mconnection_condition;
  bitpacker::uint mref_to_STC_id;
  bitpacker::uint mIN_time;
  bitpacker::uint mOUT_time;
  UO_mask_table mUO_mask_table;
  bitpacker::bits mPlayItem_random_access_flag;
  const bitpacker::reserved m_padding21;
  bitpacker::uint mstill_mode;
  bitpacker::uint mstill_time;
  multi_angle_clip_entries mmulti_angle_entries;
  STN_table mSTN_table;

  PlayItem();
  PlayItem(const PlayItem& _a);
  explicit 
  PlayItem(const char* _a);
  PlayItem(rt_stream& _a);
  virtual ~PlayItem() {}
  void layout(size_t = 0);
  void init();
  void copy(const PlayItem& _a);
  PlayItem& operator=(const PlayItem& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct PlayList : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding22;
  bitpacker::uint mnumber_of_PlayItems;
  bitpacker::uint mnumber_of_SubPaths;
  bitpacker::array<PlayItem> mPlayItem;
  bitpacker::array<SubPath> mSubPaths;

  PlayList();
  PlayList(const PlayList& _a);
  explicit 
  PlayList(const char* _a);
  PlayList(rt_stream& _a);
  virtual ~PlayList() {}
  void layout(size_t = 0);
  void init();
  void copy(const PlayList& _a);
  PlayList& operator=(const PlayList& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct AppInfoPlayList : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding23;
  bitpacker::uint mPlayList_playback_type;
  bitpacker::uint mplayback_count;
  UO_mask_table mUO_mask_table;
  bitpacker::bits mPlayList_random_access_flag;
  bitpacker::bits maudio_mix_app_flag;
  bitpacker::bits mlossless_may_bypass_mixer_flag;
  const bitpacker::reserved m_padding24;

  AppInfoPlayList();
  AppInfoPlayList(const AppInfoPlayList& _a);
  explicit 
  AppInfoPlayList(const char* _a);
  AppInfoPlayList(rt_stream& _a);
  virtual ~AppInfoPlayList() {}
  void layout(size_t = 0);
  void init();
  void copy(const AppInfoPlayList& _a);
  AppInfoPlayList& operator=(const AppInfoPlayList& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct PlayList_mpls : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  bitpacker::uint mPlayList_start_address;
  bitpacker::uint mPlayListMark_start_address;
  bitpacker::uint mExtensionData_start_address;
  const bitpacker::reserved m_padding25;
  AppInfoPlayList mAppInfoPlayList;
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = mPlayList_start_address ? mPlayList_start_address - byteOffset(&mpad1) : 0;
  			return mpad1_size;
  		}
  	
  PlayList mPlayList;
  UInt32  mbdrom_version;

  		UInt32 bdrom_ver()
  		{
  			if (mversion_number == "0100")
  				mbdrom_version = 0x0100;
  			else if (mversion_number == "0200")
  				mbdrom_version = 0x0200;
  			else
  				mbdrom_version = 0x0090;
  			return mbdrom_version;
  		}
  	
  size_t  mpad2_size;
  bitpacker::array<bitpacker::uint> mpad2;

  		size_t & pad2_cb(void)
  		{
  			mpad2_size = mPlayListMark_start_address ? mPlayListMark_start_address - byteOffset(&mpad2) : 0;
  			return mpad2_size;
  		}
  	
  PlayListMark mPlayListMark;
  size_t  mpad3_size;
  bitpacker::array<bitpacker::uint> mpad3;

  		size_t & pad3_cb(void)
  		{
  			mpad3_size = mExtensionData_start_address ? mExtensionData_start_address - byteOffset(&mpad3) : 0;
  			return mpad3_size;
  		}
  	
  ExtensionData mExtensionData;

  PlayList_mpls();
  PlayList_mpls(const PlayList_mpls& _a);
  explicit 
  PlayList_mpls(const char* _a);
  PlayList_mpls(rt_stream& _a);
  virtual ~PlayList_mpls() {}
  void layout(size_t = 0);
  void init();
  void copy(const PlayList_mpls& _a);
  PlayList_mpls& operator=(const PlayList_mpls& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

}
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayListMark& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayListMark::PlayListMarkItem& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::multi_clip_entries& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::multi_clip_entries::subClip_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::SubPlayItem& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::SubPath& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::multi_angle_clip_entries& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::multi_angle_clip_entries::angle_clip_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::stream_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::stream_attributes& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::stream_entries& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::secondary_audio_stream_entries& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::secondary_video_stream_entries& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::STN_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayItem& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayList& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::AppInfoPlayList& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayList_mpls& _a);
#endif

#if defined(_WIN32)
#pragma warning(pop)
#endif

#endif // _BDROMPlaylist_h_

