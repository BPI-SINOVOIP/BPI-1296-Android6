//-----------------------------------------------------------
// BDROMCPI.h
// Copyright (c) 2003, Sonic Solutions.  All rights reserved.
// This code was generated by BitPackerGenerator.
//-----------------------------------------------------------

#ifndef _BDROMCPI_h_
#define _BDROMCPI_h_

#undef NULL
#define NULL 0

#include "BitPacker.h"

#if defined(_WIN32)
#pragma warning(push)
#pragma warning(disable:4100)	//	unreferenced formal param
#endif

namespace BDROM { 
struct stream_PID_entry : public bitpacker::BitPacker {
  bitpacker::uint mstream_PID;
  const bitpacker::reserved m_padding0;
  bitpacker::bits mEP_stream_type;
  bitpacker::bits mnum_EP_coarse_entries;
  bitpacker::bits mnum_EP_fine_entries;
  bitpacker::uint mEP_map_for_one_stream_PID_start_address;

  stream_PID_entry();
  stream_PID_entry(const stream_PID_entry& _a);
  explicit 
  stream_PID_entry(const char* _a);
  stream_PID_entry(rt_stream& _a);
  virtual ~stream_PID_entry() {}
  void layout(size_t = 0);
  void init();
  void copy(const stream_PID_entry& _a);
  stream_PID_entry& operator=(const stream_PID_entry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct EP_fine_table : public bitpacker::BitPacker {
  size_t  mcb_dummy;
  bitpacker::array<bitpacker::bits> mEP_fine;

      size_t & cb (void);
    

      inline UInt32 get_is_angle_change_point (UInt32 EP_fine_entry)
      {
        return ((EP_fine_entry >> 31) & 0x00000001);
      }
      inline void set_is_angle_change_point (UInt32 &EP_fine_entry, UInt32 is_angle_change_point)
      {
        EP_fine_entry &= ~(0x00000001 << 31);
        EP_fine_entry |= (is_angle_change_point << 31);
      }
      UInt32 get_I_end_position_offset (UInt32 EP_fine_entry)
      {
        return ((EP_fine_entry >> 28) & 0x00000007);
      }
      void set_I_end_position_offset (UInt32 &EP_fine_entry, UInt32 I_end_position_offset)
      {
        EP_fine_entry &= ~(0x00000007 << 28);
        EP_fine_entry |= ((I_end_position_offset & 0x00000007) << 28);
      }
      UInt32 get_PTS_EP_fine (UInt32 EP_fine_entry)
      {
        return ((EP_fine_entry >> 17) & 0x000007ff);
      }
      void set_PTS_EP_fine (UInt32 &EP_fine_entry, UInt32 PTS_EP_fine)
      {
        EP_fine_entry &= ~(0x000007ff << 17);
        EP_fine_entry |= ((PTS_EP_fine & 0x000007ff) << 17);
      }
      UInt32 get_SPN_EP_fine (UInt32 EP_fine_entry)
      {
        return ((EP_fine_entry >> 0) & 0x0001ffff);
      }
      void set_SPN_EP_fine (UInt32 &EP_fine_entry, UInt32 SPN_EP_fine)
      {
        EP_fine_entry &= ~(0x0001ffff << 0);
        EP_fine_entry |= ((SPN_EP_fine & 0x0001ffff) << 0);
      }
    

  EP_fine_table();
  EP_fine_table(const EP_fine_table& _a);
  explicit 
  EP_fine_table(const char* _a);
  EP_fine_table(rt_stream& _a);
  virtual ~EP_fine_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const EP_fine_table& _a);
  EP_fine_table& operator=(const EP_fine_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct EP_map_for_one_stream : public bitpacker::BitPacker {
  stream_PID_entry *  mPID_entry;
  bitpacker::bits  mpad1_cbx_default;
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

      size_t & pad1_cb(void) {
        UpdatePointers();
        if (mPID_entry == NULL)
          mpad1_size = 0;
        else
          mpad1_size = mPID_entry->mEP_map_for_one_stream_PID_start_address ? mPID_entry->mEP_map_for_one_stream_PID_start_address - parent()->byteOffset(this) : 0;
        return mpad1_size;
      }
    
  bitpacker::uint mEP_fine_table_start_address;
  struct EP_coarse : public bitpacker::BitPacker {
    bitpacker::bits mref_to_EP_fine_id;
    bitpacker::bits mPTS_EP_coarse;
    bitpacker::bits mSPN_EP_coarse;

    EP_coarse();
    EP_coarse(const EP_coarse& _a);
    explicit 
    EP_coarse(const char* _a);
    EP_coarse(rt_stream& _a);
    virtual ~EP_coarse() {}
    void layout(size_t = 0);
    void init();
    void copy(const EP_coarse& _a);
    EP_coarse& operator=(const EP_coarse& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize) {}
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  bitpacker::array<EP_coarse> mEP_coarse;

      bitpacker::bits & pad1_cbx(void) {
      UpdatePointers();
      if (mPID_entry == NULL)
      {
        mpad1_cbx_default = 0;
        return mpad1_cbx_default;
      }
      return mPID_entry->mnum_EP_coarse_entries;
      }
    
  size_t  mpad2_size;
  bitpacker::array<bitpacker::uint> mpad2;

      size_t & pad2_cb(void) {
        mpad2_size = 0;
        if (mEP_fine_table_start_address > 0)
        {
          UpdatePointers();
          if (mPID_entry != NULL)
  		  mpad2_size = mEP_fine_table_start_address - ((mPID_entry->mnum_EP_coarse_entries * 8) + 4);
        }
        return mpad2_size;
      }
    
  mutable EP_fine_table mEP_fine_table;

  	void UpdatePointers(void);
    

  EP_map_for_one_stream();
  EP_map_for_one_stream(stream_PID_entry * PID_entry);
  EP_map_for_one_stream(const EP_map_for_one_stream& _a);
  explicit 
  EP_map_for_one_stream(const char* _a);
  EP_map_for_one_stream(rt_stream& _a);
  virtual ~EP_map_for_one_stream() {}
  void layout(size_t = 0);
  void init() {}
  void init(stream_PID_entry * PID_entry);
  void copy(const EP_map_for_one_stream& _a);
  EP_map_for_one_stream& operator=(const EP_map_for_one_stream& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct EP_map : public bitpacker::BitPacker {
  const bitpacker::reserved m_padding1;
  bitpacker::uint mnumber_of_stream_PID_entries;
  bitpacker::array<stream_PID_entry> mstream_PID_entry;
  UInt32  mi;
  bitpacker::array<EP_map_for_one_stream> mEP_map_for_one_stream;

  EP_map();
  EP_map(const EP_map& _a);
  explicit 
  EP_map(const char* _a);
  EP_map(rt_stream& _a);
  virtual ~EP_map() {}
  void layout(size_t = 0);
  void init();
  void copy(const EP_map& _a);
  EP_map& operator=(const EP_map& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct CPI : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::bits mreserved_for_future_use;
  bitpacker::bits mCPI_type;
  EP_map mEP_map;

  CPI();
  CPI(const CPI& _a);
  explicit 
  CPI(const char* _a);
  CPI(rt_stream& _a);
  virtual ~CPI() {}
  void layout(size_t = 0);
  void init();
  void copy(const CPI& _a);
  CPI& operator=(const CPI& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

}
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::stream_PID_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::EP_fine_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::EP_map_for_one_stream& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::EP_map_for_one_stream::EP_coarse& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::EP_map& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::CPI& _a);
#endif

#if defined(_WIN32)
#pragma warning(pop)
#endif

#endif // _BDROMCPI_h_

