//-----------------------------------------------------------
// BDROMIndex.h
// Copyright (c) 2003, Sonic Solutions.  All rights reserved.
// This code was generated by BitPackerGenerator.
//-----------------------------------------------------------

#ifndef _BDROMIndex_h_
#define _BDROMIndex_h_

#include "BitPacker.h"

#if defined(_WIN32)
#pragma warning(push)
#pragma warning(disable:4100)	//	unreferenced formal param
#endif
	
#include "BDROMCommonTypes.h"
namespace BDROM { 
struct Title : public bitpacker::BitPacker {
  bitpacker::bits mTitle_object_type;
  bitpacker::bits mTitle_access_type;
  const bitpacker::reserved m_padding8;
  bitpacker::bits mHDMV_Title_playback_type;
  bitpacker::bits mreserved_1;
  bitpacker::bits mTitle_mobj_id_ref;
  bitpacker::bits mreserved_2;
  bitpacker::bits mBDJ_Title_playback_type;
  bitpacker::bits mreserved_3;
  bitpacker::str mTitle_bdjo_file_name;
  bitpacker::bits mreserved_4;

  Title();
  Title(const Title& _a);
  explicit 
  Title(const char* _a);
  Title(rt_stream& _a);
  virtual ~Title() {}
  void layout(size_t = 0);
  void init();
  void copy(const Title& _a);
  Title& operator=(const Title& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct FirstPlayback : public bitpacker::BitPacker {
  bitpacker::bits mFirstPlayback_object_type;
  const bitpacker::reserved m_padding9;
  bitpacker::bits mHDMV_Title_playback_type;
  bitpacker::bits mreserved_1;
  bitpacker::uint mFirstPlayback_mobj_id_ref;
  bitpacker::bits mreserved_2;
  bitpacker::bits mBDJ_Title_playback_type;
  bitpacker::bits mreserved_3;
  bitpacker::str mFirstPlayback_bdjo_file_name;
  bitpacker::bits mreserved_4;

  FirstPlayback();
  FirstPlayback(const FirstPlayback& _a);
  explicit 
  FirstPlayback(const char* _a);
  FirstPlayback(rt_stream& _a);
  virtual ~FirstPlayback() {}
  void layout(size_t = 0);
  void init();
  void copy(const FirstPlayback& _a);
  FirstPlayback& operator=(const FirstPlayback& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct TopMenu : public bitpacker::BitPacker {
  bitpacker::bits mTopMenu_object_type;
  const bitpacker::reserved m_padding10;
  bitpacker::bits mHDMV_Title_playback_type;
  bitpacker::bits mreserved_1;
  bitpacker::uint mTopMenu_mobj_id_ref;
  bitpacker::bits mreserved_2;
  bitpacker::bits mBDJ_Title_playback_type;
  bitpacker::bits mreserved_3;
  bitpacker::str mTopMenu_bdjo_file_name;
  bitpacker::bits mreserved_4;

  TopMenu();
  TopMenu(const TopMenu& _a);
  explicit 
  TopMenu(const char* _a);
  TopMenu(rt_stream& _a);
  virtual ~TopMenu() {}
  void layout(size_t = 0);
  void init();
  void copy(const TopMenu& _a);
  TopMenu& operator=(const TopMenu& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct Indexes : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  FirstPlayback mFirstPlayback;
  TopMenu mTopMenu;
  bitpacker::uint mnumber_of_Titles;
  bitpacker::array<Title> mTitles;

  Indexes();
  Indexes(const Indexes& _a);
  explicit 
  Indexes(const char* _a);
  Indexes(rt_stream& _a);
  virtual ~Indexes() {}
  void layout(size_t = 0);
  void init();
  void copy(const Indexes& _a);
  Indexes& operator=(const Indexes& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct AppInfoBDMV : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding11;
  bitpacker::str mprovider_identifier;

  AppInfoBDMV();
  AppInfoBDMV(const AppInfoBDMV& _a);
  explicit 
  AppInfoBDMV(const char* _a);
  AppInfoBDMV(rt_stream& _a);
  virtual ~AppInfoBDMV() {}
  void layout(size_t = 0);
  void init();
  void copy(const AppInfoBDMV& _a);
  AppInfoBDMV& operator=(const AppInfoBDMV& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct index_bdmv : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  bitpacker::uint mIndexes_start_address;
  bitpacker::uint mExtensionData_start_address;
  const bitpacker::reserved m_padding12;
  AppInfoBDMV mAppInfoBDMV;
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = mIndexes_start_address ? mIndexes_start_address - byteOffset(&mpad1) : 0;
  			return mpad1_size;
  		}
  	
  mutable Indexes mIndexes;
  ExtensionData mExtensionData;

  index_bdmv();
  index_bdmv(const index_bdmv& _a);
  explicit 
  index_bdmv(const char* _a);
  index_bdmv(rt_stream& _a);
  virtual ~index_bdmv() {}
  void layout(size_t = 0);
  void init();
  void copy(const index_bdmv& _a);
  index_bdmv& operator=(const index_bdmv& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct navigation_command : public bitpacker::BitPacker {
  bitpacker::bits moperand_count;
  bitpacker::bits mcommand_group;
  bitpacker::bits mcommand_subgroup;
  bitpacker::bits mI_flag_for_Operand1;
  bitpacker::bits mI_flag_for_Operand2;
  const bitpacker::reserved m_padding13;
  bitpacker::bits mbranch_option;
  const bitpacker::reserved m_padding14;
  bitpacker::bits mcompare_option;
  const bitpacker::reserved m_padding15;
  bitpacker::bits mset_option;
  bitpacker::uint moperand1;
  bitpacker::uint moperand2;

  	UInt32 GetOperand1_ImmediateValue(void)
  	{
  		return moperand1;
  	}
  	UInt8 GetOperand1_RegFlag(void)
  	{
  		return (UInt8)((moperand1 & 0x80000000) >> 31);
  	}
  	UInt16 GetOperand1_RegisterNumber(void)
  	{
  		return (UInt16)(moperand1 & 0x00000FFF);
  	}

  	UInt32 GetOperationCode(void)
  	{
  		UInt32 opCode = (moperand_count << 29) | (mcommand_group << 27) | (mcommand_subgroup << 24) |
  						(mI_flag_for_Operand1 << 23) | (mI_flag_for_Operand2 << 22) | (mbranch_option << 16) |
  						(mcompare_option << 8) | mset_option;
  		return opCode;
  	}

  	UInt32 GetOperand2_ImmediateValue(void)
  	{
  		return moperand2;
  	}
  	UInt8 GetOperand2_RegFlag(void)
  	{
  		return (UInt8)((moperand2 & 0x80000000) >> 31);
  	}
  	UInt16 GetOperand2_RegisterNumber(void)
  	{
  		return (UInt16)(moperand2 & 0x00000FFF);
  	}
  	

  navigation_command();
  navigation_command(const navigation_command& _a);
  explicit 
  navigation_command(const char* _a);
  navigation_command(rt_stream& _a);
  virtual ~navigation_command() {}
  void layout(size_t = 0);
  void init();
  void copy(const navigation_command& _a);
  navigation_command& operator=(const navigation_command& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct MovieObject : public bitpacker::BitPacker {
  struct TerminalInfo : public bitpacker::BitPacker {
    bitpacker::bits mresume_intention_flag;
    bitpacker::bits mmenu_call_mask;
    bitpacker::bits mtitle_search_mask;
    const bitpacker::reserved m_padding16;

    TerminalInfo();
    TerminalInfo(const TerminalInfo& _a);
    explicit 
    TerminalInfo(const char* _a);
    TerminalInfo(rt_stream& _a);
    virtual ~TerminalInfo() {}
    void layout(size_t = 0);
    void init();
    void copy(const TerminalInfo& _a);
    TerminalInfo& operator=(const TerminalInfo& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize) {}
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  TerminalInfo mTerminalInfo;
  bitpacker::uint mnumber_of_navigation_commands;
  bitpacker::array<navigation_command> mnavigation_command;

  MovieObject();
  MovieObject(const MovieObject& _a);
  explicit 
  MovieObject(const char* _a);
  MovieObject(rt_stream& _a);
  virtual ~MovieObject() {}
  void layout(size_t = 0);
  void init();
  void copy(const MovieObject& _a);
  MovieObject& operator=(const MovieObject& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct MovieObjects : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding17;
  bitpacker::uint mnumber_of_mobjs;
  bitpacker::array<MovieObject> mMovieObject;

  MovieObjects();
  MovieObjects(const MovieObjects& _a);
  explicit 
  MovieObjects(const char* _a);
  MovieObjects(rt_stream& _a);
  virtual ~MovieObjects() {}
  void layout(size_t = 0);
  void init();
  void copy(const MovieObjects& _a);
  MovieObjects& operator=(const MovieObjects& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct MovieObject_bdmv : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  const bitpacker::reserved m_padding18;
  MovieObjects mMovieObjects;

  MovieObject_bdmv();
  MovieObject_bdmv(const MovieObject_bdmv& _a);
  explicit 
  MovieObject_bdmv(const char* _a);
  MovieObject_bdmv(rt_stream& _a);
  virtual ~MovieObject_bdmv() {}
  void layout(size_t = 0);
  void init();
  void copy(const MovieObject_bdmv& _a);
  MovieObject_bdmv& operator=(const MovieObject_bdmv& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct TerminalInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::str mdefault_font_file_name;
  bitpacker::bits mInitial_HAVI_configuration_id;
  bitpacker::bits mmenu_call_mask;
  bitpacker::bits mtitle_search_mask;
  bitpacker::bits mmouse_supported;
  bitpacker::bits mmouse_interest;
  const bitpacker::reserved m_padding19;

  TerminalInfo();
  TerminalInfo(const TerminalInfo& _a);
  explicit 
  TerminalInfo(const char* _a);
  TerminalInfo(rt_stream& _a);
  virtual ~TerminalInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const TerminalInfo& _a);
  TerminalInfo& operator=(const TerminalInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct AppCacheInfoEntry : public bitpacker::BitPacker {
  bitpacker::uint mentry_type;
  bitpacker::str mref_to_name;
  bitpacker::str mlanguage_code;
  const bitpacker::reserved m_padding20;

  AppCacheInfoEntry();
  AppCacheInfoEntry(const AppCacheInfoEntry& _a);
  explicit 
  AppCacheInfoEntry(const char* _a);
  AppCacheInfoEntry(rt_stream& _a);
  virtual ~AppCacheInfoEntry() {}
  void layout(size_t = 0);
  void init();
  void copy(const AppCacheInfoEntry& _a);
  AppCacheInfoEntry& operator=(const AppCacheInfoEntry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct AppCacheInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mnumber_of_entries;
  const bitpacker::reserved m_padding21;
  bitpacker::array<AppCacheInfoEntry> mentries;

  AppCacheInfo();
  AppCacheInfo(const AppCacheInfo& _a);
  explicit 
  AppCacheInfo(const char* _a);
  AppCacheInfo(rt_stream& _a);
  virtual ~AppCacheInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const AppCacheInfo& _a);
  AppCacheInfo& operator=(const AppCacheInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct PlayList_file_names : public bitpacker::BitPacker {
  bitpacker::str mPlayList_file_name;
  const bitpacker::reserved m_padding22;

  PlayList_file_names();
  PlayList_file_names(const PlayList_file_names& _a);
  explicit 
  PlayList_file_names(const char* _a);
  PlayList_file_names(rt_stream& _a);
  virtual ~PlayList_file_names() {}
  void layout(size_t = 0);
  void init();
  void copy(const PlayList_file_names& _a);
  PlayList_file_names& operator=(const PlayList_file_names& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct TableOfAccessiblePlaylists : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::bits mnumber_of_acc_PlayLists;
  bitpacker::bits maccess_to_all_flag;
  bitpacker::bits mautostart_first_PlayList_flag;
  const bitpacker::reserved m_padding23;
  bitpacker::array<PlayList_file_names> mPlayList_file_names;

  TableOfAccessiblePlaylists();
  TableOfAccessiblePlaylists(const TableOfAccessiblePlaylists& _a);
  explicit 
  TableOfAccessiblePlaylists(const char* _a);
  TableOfAccessiblePlaylists(rt_stream& _a);
  virtual ~TableOfAccessiblePlaylists() {}
  void layout(size_t = 0);
  void init();
  void copy(const TableOfAccessiblePlaylists& _a);
  TableOfAccessiblePlaylists& operator=(const TableOfAccessiblePlaylists& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct application_identifier : public bitpacker::BitPacker {
  bitpacker::uint morganization_id;
  bitpacker::uint mapplication_id;

  application_identifier();
  application_identifier(const application_identifier& _a);
  explicit 
  application_identifier(const char* _a);
  application_identifier(rt_stream& _a);
  virtual ~application_identifier() {}
  void layout(size_t = 0);
  void init();
  void copy(const application_identifier& _a);
  application_identifier& operator=(const application_identifier& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct application_profile : public bitpacker::BitPacker {
  bitpacker::uint mapplication_profile;
  bitpacker::uint mversion_major;
  bitpacker::uint mversion_minor;
  bitpacker::uint mversion_micro;
  const bitpacker::reserved m_padding24;

  application_profile();
  application_profile(const application_profile& _a);
  explicit 
  application_profile(const char* _a);
  application_profile(rt_stream& _a);
  virtual ~application_profile() {}
  void layout(size_t = 0);
  void init();
  void copy(const application_profile& _a);
  application_profile& operator=(const application_profile& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct application_name : public bitpacker::BitPacker {
  bitpacker::str mapplication_language_code;
  bitpacker::uint mapplication_name_length;
  bitpacker::array<bitpacker::uint> mapplication_name;

  application_name();
  application_name(const application_name& _a);
  explicit 
  application_name(const char* _a);
  application_name(rt_stream& _a);
  virtual ~application_name() {}
  void layout(size_t = 0);
  void init();
  void copy(const application_name& _a);
  application_name& operator=(const application_name& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct application_descriptor : public bitpacker::BitPacker {
  bitpacker::uint mdescriptor_tag;
  const bitpacker::reserved m_padding25;
  bitpacker::uint mdescriptor_length;
  const bitpacker::reserved m_padding26;
  bitpacker::bits mapplication_profiles_count;
  const bitpacker::reserved m_padding27;
  bitpacker::array<application_profile> mapplication_profiles;
  bitpacker::uint mapplication_priority;
  bitpacker::bits mapplication_binding;
  bitpacker::bits mvisibility;
  const bitpacker::reserved m_padding28;
  bitpacker::uint mnumber_of_application_name_bytes;
  bitpacker::array<bitpacker::uint> mapplication_name_bytes;

  		UInt32 GetNumberOfApplicationNames(void)
  		{
  			UInt32 numItems = 0, itemOffset = 1;
  			while ((itemOffset + 3) < mnumber_of_application_name_bytes)
  			{
  				numItems++;
  				itemOffset += (4 + (UInt32)mapplication_name_bytes[itemOffset+3]);
  			}
  			return numItems;
  		}

  		void GetApplicationLanguageCode(UInt32 itemIndex, UInt32 & infoStartByteIndex, UInt32 & infoLength)
  		{
  			infoStartByteIndex = 1;
  			infoLength = 0;
  			UInt32 numItems = 0, itemOffset = 1;
  			while ((itemOffset + 3) < mnumber_of_application_name_bytes)
  			{
  				numItems++;
  				if (numItems == itemIndex)
  				{
  					infoStartByteIndex = itemOffset;
  					infoLength = 3;
  					return;
  				}
  				else
  				{
  					itemOffset += (4 + (UInt32)mapplication_name_bytes[itemOffset+3]);
  				}
  			}
  		}

  		UInt32 GetApplicationNameLength(UInt32 itemIndex)
  		{
  			UInt32 numItems = 0, itemOffset = 1;
  			while ((itemOffset + 3) < mnumber_of_application_name_bytes)
  			{
  				numItems++;
  				if (numItems == itemIndex)
  					return (UInt32)mapplication_name_bytes[itemOffset+3];
  				else
  					itemOffset += (4 + (UInt32)mapplication_name_bytes[itemOffset+3]);
  			}
  			return 0;
  		}

  		void GetApplicationName(UInt32 itemIndex, UInt32 & infoStartByteIndex, UInt32 & infoLength)
  		{
  			infoStartByteIndex = 1;
  			infoLength = 0;
  			UInt32 numItems = 0, itemOffset = 1;
  			while ((itemOffset + 3) < mnumber_of_application_name_bytes)
  			{
  				numItems++;
  				if (numItems == itemIndex)
  				{
  					infoStartByteIndex = itemOffset + 4;
  					infoLength = (UInt32)mapplication_name_bytes[itemOffset+3];
  					return;
  				}
  				else
  				{
  					itemOffset += (4 + (UInt32)mapplication_name_bytes[itemOffset+3]);
  				}
  			}
  		}
  	
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = byteOffset(&mpad1) % 2 ? 1 : 0;
  			return mpad1_size;
  		}
  	
  bitpacker::uint mapplication_icon_locator_length;
  bitpacker::array<bitpacker::uint> mapplication_icon_locator_byte;
  size_t  mpad2_size;
  bitpacker::array<bitpacker::uint> mpad2;

  		size_t & pad2_cb(void)
  		{
  			mpad2_size = byteOffset(&mpad2) % 2 ? 1 : 0;
  			return mpad2_size;
  		}
  	
  bitpacker::uint mapplication_icon_flags;
  bitpacker::uint mbase_directory_length;
  bitpacker::array<bitpacker::uint> mbase_directory_byte;
  size_t  mpad3_size;
  bitpacker::array<bitpacker::uint> mpad3;

  		size_t & pad3_cb(void)
  		{
  			mpad3_size = byteOffset(&mpad3) % 2 ? 1 : 0;
  			return mpad3_size;
  		}
  	
  bitpacker::uint mclasspath_extension_length;
  bitpacker::array<bitpacker::uint> mclasspath_extension_byte;
  size_t  mpad4_size;
  bitpacker::array<bitpacker::uint> mpad4;

  		size_t & pad4_cb(void)
  		{
  			mpad4_size = byteOffset(&mpad4) % 2 ? 1 : 0;
  			return mpad4_size;
  		}
  	
  bitpacker::uint minitial_class_name_length;
  bitpacker::array<bitpacker::uint> minitial_class_name_byte;
  size_t  mpad5_size;
  bitpacker::array<bitpacker::uint> mpad5;

  		size_t & pad5_cb(void)
  		{
  			mpad5_size = byteOffset(&mpad5) % 2 ? 1 : 0;
  			return mpad5_size;
  		}
  	
  bitpacker::uint mnumber_of_overall_parameter_bytes;
  bitpacker::array<bitpacker::uint> moverall_parameter_bytes;

  		UInt32 GetNumberOfParameters(void)
  		{
  			UInt32 numItems = 0, itemOffset = 1;
  			while (itemOffset <= mnumber_of_overall_parameter_bytes)
  			{
  				numItems++;
  				itemOffset += (1 + (UInt32)moverall_parameter_bytes[itemOffset]);
  			}
  			return numItems;
  		}

  		UInt32 GetParameterLength(UInt32 itemIndex)
  		{
  			UInt32 numItems = 0, itemOffset = 1;
  			while (itemOffset <= mnumber_of_overall_parameter_bytes)
  			{
  				numItems++;
  				if (numItems == itemIndex)
  					return (UInt32)moverall_parameter_bytes[itemOffset];
  				else
  					itemOffset += (1 + (UInt32)moverall_parameter_bytes[itemOffset]);
  			}
  			return 0;
  		}

  		void GetParameter(UInt32 itemIndex, UInt32 & infoStartByteIndex, UInt32 & infoLength)
  		{
  			infoStartByteIndex = 1;
  			infoLength = 0;
  			UInt32 numItems = 0, itemOffset = 1;
  			while (itemOffset <= mnumber_of_overall_parameter_bytes)
  			{
  				numItems++;
  				if (numItems == itemIndex)
  				{
  					infoStartByteIndex = itemOffset + 1;
  					infoLength = (UInt32)moverall_parameter_bytes[itemOffset];
  					return;
  				}
  				else
  				{
  					itemOffset += (1 + (UInt32)moverall_parameter_bytes[itemOffset]);
  				}
  			}
  		}
  	

  		UInt32 bdrom_ver(void) const;
  	
  bitpacker::array<bitpacker::uint> mpad6;
  size_t  mpad6_size;

  		size_t & pad6_cb(void)
  		{
  			mpad6_size = byteOffset(&mpad6) % 2 ? 1 : 0;
  			return mpad6_size;
  		}
  	

  application_descriptor();
  application_descriptor(const application_descriptor& _a);
  explicit 
  application_descriptor(const char* _a);
  application_descriptor(rt_stream& _a);
  virtual ~application_descriptor() {}
  void layout(size_t = 0);
  void init();
  void copy(const application_descriptor& _a);
  application_descriptor& operator=(const application_descriptor& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct application : public bitpacker::BitPacker {
  bitpacker::uint mapplication_control_code;
  bitpacker::bits mapplication_type;
  const bitpacker::reserved m_padding29;
  application_identifier mapplication_identifier;
  application_descriptor mapplication_descriptor;

  application();
  application(const application& _a);
  explicit 
  application(const char* _a);
  application(rt_stream& _a);
  virtual ~application() {}
  void layout(size_t = 0);
  void init();
  void copy(const application& _a);
  application& operator=(const application& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ApplicationManagementTable : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mnumber_of_applications;
  const bitpacker::reserved m_padding30;
  bitpacker::array<application> mapplications;

  ApplicationManagementTable();
  ApplicationManagementTable(const ApplicationManagementTable& _a);
  explicit 
  ApplicationManagementTable(const char* _a);
  ApplicationManagementTable(rt_stream& _a);
  virtual ~ApplicationManagementTable() {}
  void layout(size_t = 0);
  void init();
  void copy(const ApplicationManagementTable& _a);
  ApplicationManagementTable& operator=(const ApplicationManagementTable& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct KeyInterestTable : public bitpacker::BitPacker {
  bitpacker::bits mVK_PLAY;
  bitpacker::bits mVK_STOP;
  bitpacker::bits mVK_FAST_FWD;
  bitpacker::bits mVK_REWIND;
  bitpacker::bits mVK_TRACK_NEXT;
  bitpacker::bits mVK_TRACK_PREV;
  bitpacker::bits mVK_PAUSE;
  bitpacker::bits mVK_STILL_OFF;
  bitpacker::bits mVK_SECONDARY_AUDIO_ENABLE_DISABLE;
  bitpacker::bits mVK_SECONDARY_VIDEO_ENABLE_DISABLE;
  bitpacker::bits mVK_PG_TEXTST_ENABLE_DISABLE;
  const bitpacker::reserved m_padding31;

  KeyInterestTable();
  KeyInterestTable(const KeyInterestTable& _a);
  explicit 
  KeyInterestTable(const char* _a);
  KeyInterestTable(rt_stream& _a);
  virtual ~KeyInterestTable() {}
  void layout(size_t = 0);
  void init();
  void copy(const KeyInterestTable& _a);
  KeyInterestTable& operator=(const KeyInterestTable& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct FileAccessInfo : public bitpacker::BitPacker {
  bitpacker::uint mdirectory_paths_length;
  bitpacker::array<bitpacker::uint> mdirectory_paths_byte;

  FileAccessInfo();
  FileAccessInfo(const FileAccessInfo& _a);
  explicit 
  FileAccessInfo(const char* _a);
  FileAccessInfo(rt_stream& _a);
  virtual ~FileAccessInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const FileAccessInfo& _a);
  FileAccessInfo& operator=(const FileAccessInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct BDJObject_bdjo : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  bitpacker::uint mTerminalInfo_start_address;
  bitpacker::uint mAppCacheInfo_start_address;
  bitpacker::uint mTableOfAcccessiblePlayLists_start_address;
  bitpacker::uint mApplicationManagementTable_start_address;
  bitpacker::uint mKeyInterestTable_start_address;
  bitpacker::uint mFileAccessInfo_start_address;
  const bitpacker::reserved m_padding32;
  TerminalInfo mTerminalInfo;
  bitpacker::array<bitpacker::uint> mpad1;
  size_t  mpad1_size;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = mAppCacheInfo_start_address ? mAppCacheInfo_start_address - byteOffset(&mpad1) : 0;
  			return mpad1_size;
  		}
  	
  AppCacheInfo mAppCacheInfo;
  bitpacker::array<bitpacker::uint> mpad2;
  size_t  mpad2_size;

  		size_t & pad2_cb(void)
  		{
  			mpad2_size = mTableOfAcccessiblePlayLists_start_address ? mTableOfAcccessiblePlayLists_start_address - byteOffset(&mpad2) : 0;
  			return mpad2_size;
  		}
  	
  UInt32  mbdrom_version;

  		UInt32 bdrom_ver()
  		{
  			if (mversion_number == "0100")
  				mbdrom_version = 0x0100;
  			else if (mversion_number == "0200")
  				mbdrom_version = 0x0200;
  			else
  				mbdrom_version = 0x0090;
  			return mbdrom_version;
  		}
  	
  TableOfAccessiblePlaylists mTableOfAccessiblePlaylists;
  bitpacker::array<bitpacker::uint> mpad3;
  size_t  mpad3_size;

  		size_t & pad3_cb(void)
  		{
  			mpad3_size = mApplicationManagementTable_start_address ? mApplicationManagementTable_start_address - byteOffset(&mpad3) : 0;
  			return mpad3_size;
  		}
  	
  ApplicationManagementTable mApplicationManagementTable;
  bitpacker::array<bitpacker::uint> mpad4;
  size_t  mpad4_size;

  		size_t & pad4_cb(void)
  		{
  			mpad4_size = mKeyInterestTable_start_address ? mKeyInterestTable_start_address - byteOffset(&mpad4) : 0;
  			return mpad4_size;
  		}
  	
  KeyInterestTable mKeyInterestTable;
  FileAccessInfo mFileAccessInfo;

  BDJObject_bdjo();
  BDJObject_bdjo(const BDJObject_bdjo& _a);
  explicit 
  BDJObject_bdjo(const char* _a);
  BDJObject_bdjo(rt_stream& _a);
  virtual ~BDJObject_bdjo() {}
  void layout(size_t = 0);
  void init();
  void copy(const BDJObject_bdjo& _a);
  BDJObject_bdjo& operator=(const BDJObject_bdjo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ID_Data : public bitpacker::BitPacker {
  bitpacker::array<bitpacker::uint> mOrganization_ID;
  bitpacker::array<bitpacker::uint> mDisc_ID;
  const bitpacker::reserved m_padding33;

  ID_Data();
  ID_Data(const ID_Data& _a);
  explicit 
  ID_Data(const char* _a);
  ID_Data(rt_stream& _a);
  virtual ~ID_Data() {}
  void layout(size_t = 0);
  void init();
  void copy(const ID_Data& _a);
  ID_Data& operator=(const ID_Data& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct id_bdmv : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  const bitpacker::reserved m_padding34;
  ID_Data mID_Data;

  id_bdmv();
  id_bdmv(const id_bdmv& _a);
  explicit 
  id_bdmv(const char* _a);
  id_bdmv(rt_stream& _a);
  virtual ~id_bdmv() {}
  void layout(size_t = 0);
  void init();
  void copy(const id_bdmv& _a);
  id_bdmv& operator=(const id_bdmv& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

}
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::Title& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::FirstPlayback& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::TopMenu& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::Indexes& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::AppInfoBDMV& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::index_bdmv& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::navigation_command& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::MovieObject& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::MovieObject::TerminalInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::MovieObjects& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::MovieObject_bdmv& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::TerminalInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::AppCacheInfoEntry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::AppCacheInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PlayList_file_names& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::TableOfAccessiblePlaylists& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::application_identifier& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::application_profile& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::application_name& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::application_descriptor& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::application& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ApplicationManagementTable& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::KeyInterestTable& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::FileAccessInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::BDJObject_bdjo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ID_Data& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::id_bdmv& _a);
#endif
#if defined(_WIN32)
#pragma warning(pop)
#endif

#endif // _BDROMIndex_h_

