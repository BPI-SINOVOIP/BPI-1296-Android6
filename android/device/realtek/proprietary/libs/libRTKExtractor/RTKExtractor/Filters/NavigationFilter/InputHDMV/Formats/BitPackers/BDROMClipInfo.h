//-----------------------------------------------------------
// BDROMClipInfo.h
// Copyright (c) 2003, Sonic Solutions.  All rights reserved.
// This code was generated by BitPackerGenerator.
//-----------------------------------------------------------

#ifndef _BDROMClipInfo_h_
#define _BDROMClipInfo_h_

#include "BitPacker.h"

#if defined(_WIN32)
#pragma warning(push)
#pragma warning(disable:4100)	//	unreferenced formal param
#endif
	
#include "BDROMCommonTypes.h"
#include "BDROMCPI.h"
namespace BDROM { 
struct ClipMark : public bitpacker::BitPacker {
  bitpacker::uint mlength;

  ClipMark();
  ClipMark(const ClipMark& _a);
  explicit 
  ClipMark(const char* _a);
  ClipMark(rt_stream& _a);
  virtual ~ClipMark() {}
  void layout(size_t = 0);
  void init();
  void copy(const ClipMark& _a);
  ClipMark& operator=(const ClipMark& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ISRC : public bitpacker::BitPacker {
  bitpacker::str mcountry_code;
  bitpacker::str mcopyright_holder;
  bitpacker::str mrecording_year;
  bitpacker::str mrecording_number;

  ISRC();
  ISRC(const ISRC& _a);
  explicit 
  ISRC(const char* _a);
  ISRC(rt_stream& _a);
  virtual ~ISRC() {}
  void layout(size_t = 0);
  void init();
  void copy(const ISRC& _a);
  ISRC& operator=(const ISRC& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct video_format_table : public bitpacker::BitPacker {
  bitpacker::uint mvideo_format;
  bitpacker::uint mframe_rate;
  bitpacker::uint maspect_ratio;
  const bitpacker::reserved m_padding10;
  bitpacker::bits mcc_flag;
  const bitpacker::reserved m_padding11;
  bitpacker::bits mreserved_1;
  ISRC mISRC;
  const bitpacker::reserved m_padding12;

  		UInt32 bdrom_ver(void) const;
  	

  video_format_table();
  video_format_table(const video_format_table& _a);
  explicit 
  video_format_table(const char* _a);
  video_format_table(rt_stream& _a);
  virtual ~video_format_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const video_format_table& _a);
  video_format_table& operator=(const video_format_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct audio_format_table : public bitpacker::BitPacker {
  bitpacker::uint maudio_presentation_type;
  bitpacker::uint msampling_frequency;
  bitpacker::str maudio_language_code;
  ISRC mISRC;
  const bitpacker::reserved m_padding13;

  audio_format_table();
  audio_format_table(const audio_format_table& _a);
  explicit 
  audio_format_table(const char* _a);
  audio_format_table(rt_stream& _a);
  virtual ~audio_format_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const audio_format_table& _a);
  audio_format_table& operator=(const audio_format_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct PG_format_table : public bitpacker::BitPacker {
  bitpacker::str mPG_language_code;
  const bitpacker::reserved m_padding14;
  ISRC mISRC;
  const bitpacker::reserved m_padding15;

  PG_format_table();
  PG_format_table(const PG_format_table& _a);
  explicit 
  PG_format_table(const char* _a);
  PG_format_table(rt_stream& _a);
  virtual ~PG_format_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const PG_format_table& _a);
  PG_format_table& operator=(const PG_format_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct IG_format_table : public bitpacker::BitPacker {
  bitpacker::str mIG_language_code;
  const bitpacker::reserved m_padding16;
  ISRC mISRC;
  const bitpacker::reserved m_padding17;

  IG_format_table();
  IG_format_table(const IG_format_table& _a);
  explicit 
  IG_format_table(const char* _a);
  IG_format_table(rt_stream& _a);
  virtual ~IG_format_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const IG_format_table& _a);
  IG_format_table& operator=(const IG_format_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct textST_format_table : public bitpacker::BitPacker {
  bitpacker::uint mcharacter_code;
  bitpacker::str mtextST_language_code;
  ISRC mISRC;
  const bitpacker::reserved m_padding18;

  textST_format_table();
  textST_format_table(const textST_format_table& _a);
  explicit 
  textST_format_table(const char* _a);
  textST_format_table(rt_stream& _a);
  virtual ~textST_format_table() {}
  void layout(size_t = 0);
  void init();
  void copy(const textST_format_table& _a);
  textST_format_table& operator=(const textST_format_table& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct StreamCodingInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mstream_coding_type;
  video_format_table mvideo_format_table;
  audio_format_table maudio_format_table;
  PG_format_table mPG_format_table;
  IG_format_table mIG_format_table;
  textST_format_table mtextST_format_table;

  StreamCodingInfo();
  StreamCodingInfo(const StreamCodingInfo& _a);
  explicit 
  StreamCodingInfo(const char* _a);
  StreamCodingInfo(rt_stream& _a);
  virtual ~StreamCodingInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const StreamCodingInfo& _a);
  StreamCodingInfo& operator=(const StreamCodingInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct StreamInfo : public bitpacker::BitPacker {
  bitpacker::uint mstream_PID;
  StreamCodingInfo mStreamCodingInfo;

  StreamInfo();
  StreamInfo(const StreamInfo& _a);
  explicit 
  StreamInfo(const char* _a);
  StreamInfo(rt_stream& _a);
  virtual ~StreamInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const StreamInfo& _a);
  StreamInfo& operator=(const StreamInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct program_sequence : public bitpacker::BitPacker {
  bitpacker::uint mSPN_program_sequence_start;
  bitpacker::uint mprogram_map_PID;
  bitpacker::uint mnum_of_streams_in_ps;
  const bitpacker::reserved m_padding19;
  bitpacker::array<StreamInfo> mStreamInfo;

  program_sequence();
  program_sequence(const program_sequence& _a);
  explicit 
  program_sequence(const char* _a);
  program_sequence(rt_stream& _a);
  virtual ~program_sequence() {}
  void layout(size_t = 0);
  void init();
  void copy(const program_sequence& _a);
  program_sequence& operator=(const program_sequence& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ProgramInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding20;
  bitpacker::uint mnum_of_program_sequences;
  bitpacker::array<program_sequence> mprogram_sequence;

  ProgramInfo();
  ProgramInfo(const ProgramInfo& _a);
  explicit 
  ProgramInfo(const char* _a);
  ProgramInfo(rt_stream& _a);
  virtual ~ProgramInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const ProgramInfo& _a);
  ProgramInfo& operator=(const ProgramInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct SequenceInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding21;
  bitpacker::uint mnum_of_ATC_sequences;
  struct ATC_sequence : public bitpacker::BitPacker {
    bitpacker::uint mSPN_ATC_start;
    bitpacker::uint mnum_of_STC_sequences;
    bitpacker::uint moffset_STC_id;
    struct STC_sequence : public bitpacker::BitPacker {
      bitpacker::uint mPCR_PID;
      bitpacker::uint mSPN_STC_start;
      bitpacker::uint mpresentation_start_time;
      bitpacker::uint mpresentation_end_time;

      STC_sequence();
      STC_sequence(const STC_sequence& _a);
      explicit 
      STC_sequence(const char* _a);
      STC_sequence(rt_stream& _a);
      virtual ~STC_sequence() {}
      void layout(size_t = 0);
      void init();
      void copy(const STC_sequence& _a);
      STC_sequence& operator=(const STC_sequence& _a);
      virtual void resizeEvent(size_t _selector, size_t _newSize) {}
      void addOffset(size_t& _a) const;
      bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
      void pack(bitpacker::BitPtr& _a) const;
      void bind(bitpacker::ConstBitPtr& _a);
      void read(rt_stream& _is, size_t& _offset);
      void refresh() {}
      void validate(rt_stream& _os) const;
      #ifdef BITPACKER_ENABLE_PRINT
      void print(rt_stream& _os, int _indent) const;
      #endif
    };

    bitpacker::array<STC_sequence> mSTC_sequence;

    ATC_sequence();
    ATC_sequence(const ATC_sequence& _a);
    explicit 
    ATC_sequence(const char* _a);
    ATC_sequence(rt_stream& _a);
    virtual ~ATC_sequence() {}
    void layout(size_t = 0);
    void init();
    void copy(const ATC_sequence& _a);
    ATC_sequence& operator=(const ATC_sequence& _a);
    virtual void resizeEvent(size_t _selector, size_t _newSize);
    void addOffset(size_t& _a) const;
    bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
    void pack(bitpacker::BitPtr& _a) const;
    void bind(bitpacker::ConstBitPtr& _a);
    void read(rt_stream& _is, size_t& _offset);
    void refresh() {}
    void validate(rt_stream& _os) const;
    #ifdef BITPACKER_ENABLE_PRINT
    void print(rt_stream& _os, int _indent) const;
    #endif
  };

  bitpacker::array<ATC_sequence> mATC_sequence;

  SequenceInfo();
  SequenceInfo(const SequenceInfo& _a);
  explicit 
  SequenceInfo(const char* _a);
  SequenceInfo(rt_stream& _a);
  virtual ~SequenceInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const SequenceInfo& _a);
  SequenceInfo& operator=(const SequenceInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct TS_type_info_block : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mValidity_flags;
  bitpacker::str mFormat_identifier;
  bitpacker::str mNetwork_information;
  bitpacker::str mStream_format_name;

  TS_type_info_block();
  TS_type_info_block(const TS_type_info_block& _a);
  explicit 
  TS_type_info_block(const char* _a);
  TS_type_info_block(rt_stream& _a);
  virtual ~TS_type_info_block() {}
  void layout(size_t = 0);
  void init();
  void copy(const TS_type_info_block& _a);
  TS_type_info_block& operator=(const TS_type_info_block& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ATC_delta_entry : public bitpacker::BitPacker {
  bitpacker::uint mATC_delta;
  bitpacker::str mfollowing_Clip_Information_file_name;
  bitpacker::str mClip_codec_identifier;
  const bitpacker::reserved m_padding22;

  ATC_delta_entry();
  ATC_delta_entry(const ATC_delta_entry& _a);
  explicit 
  ATC_delta_entry(const char* _a);
  ATC_delta_entry(rt_stream& _a);
  virtual ~ATC_delta_entry() {}
  void layout(size_t = 0);
  void init();
  void copy(const ATC_delta_entry& _a);
  ATC_delta_entry& operator=(const ATC_delta_entry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct font_files : public bitpacker::BitPacker {
  bitpacker::str mfont_file_name;
  const bitpacker::reserved m_padding23;

  font_files();
  font_files(const font_files& _a);
  explicit 
  font_files(const char* _a);
  font_files(rt_stream& _a);
  virtual ~font_files() {}
  void layout(size_t = 0);
  void init();
  void copy(const font_files& _a);
  font_files& operator=(const font_files& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ClipInfo : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  const bitpacker::reserved m_padding24;
  bitpacker::uint mClip_stream_type;
  bitpacker::uint mapplication_type;
  const bitpacker::reserved m_padding25;
  bitpacker::bits mis_ATC_delta;
  bitpacker::uint mTS_recording_rate;
  bitpacker::uint mnum_of_source_packets;
  const bitpacker::reserved m_padding26;
  TS_type_info_block mTS_type_info_block;
  bitpacker::uint mreserved2;
  bitpacker::uint mnumber_of_ATC_delta_entries;
  bitpacker::array<ATC_delta_entry> mATC_delta_entries;
  bitpacker::bits mreserved3;
  bitpacker::uint mnumber_of_font_files;
  bitpacker::array<font_files> mfont_files;

  ClipInfo();
  ClipInfo(const ClipInfo& _a);
  explicit 
  ClipInfo(const char* _a);
  ClipInfo(rt_stream& _a);
  virtual ~ClipInfo() {}
  void layout(size_t = 0);
  void init();
  void copy(const ClipInfo& _a);
  ClipInfo& operator=(const ClipInfo& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct HDMV_LPCM_down_mix_coefficient_entry : public bitpacker::BitPacker {
  bitpacker::uint mref_to_stream_index;
  bitpacker::array<bitpacker::uint> mcoeff_data;

  		void GetAsArray(unsigned char * pDst);	// pDst must point to >= 18 byte buffer
  	

  HDMV_LPCM_down_mix_coefficient_entry();
  HDMV_LPCM_down_mix_coefficient_entry(const HDMV_LPCM_down_mix_coefficient_entry& _a);
  explicit 
  HDMV_LPCM_down_mix_coefficient_entry(const char* _a);
  HDMV_LPCM_down_mix_coefficient_entry(rt_stream& _a);
  virtual ~HDMV_LPCM_down_mix_coefficient_entry() {}
  void layout(size_t = 0);
  void init();
  void copy(const HDMV_LPCM_down_mix_coefficient_entry& _a);
  HDMV_LPCM_down_mix_coefficient_entry& operator=(const HDMV_LPCM_down_mix_coefficient_entry& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize) {}
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct HDMV_LPCM_down_mix_coefficient : public bitpacker::BitPacker {
  bitpacker::uint mlength;
  bitpacker::uint mnumber_of_coeff_entries;
  bitpacker::array<HDMV_LPCM_down_mix_coefficient_entry> mCoeffEntries;

  HDMV_LPCM_down_mix_coefficient();
  HDMV_LPCM_down_mix_coefficient(const HDMV_LPCM_down_mix_coefficient& _a);
  explicit 
  HDMV_LPCM_down_mix_coefficient(const char* _a);
  HDMV_LPCM_down_mix_coefficient(rt_stream& _a);
  virtual ~HDMV_LPCM_down_mix_coefficient() {}
  void layout(size_t = 0);
  void init();
  void copy(const HDMV_LPCM_down_mix_coefficient& _a);
  HDMV_LPCM_down_mix_coefficient& operator=(const HDMV_LPCM_down_mix_coefficient& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh() {}
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

struct ClipInfo_clpi : public bitpacker::BitPacker {
  bitpacker::str mtype_indicator;
  bitpacker::str mversion_number;
  bitpacker::uint mSequenceInfo_start_address;
  bitpacker::uint mProgramInfo_start_address;
  bitpacker::uint mCPI_start_address;
  bitpacker::uint mClipMark_start_address;
  bitpacker::uint mExtensionData_start_address;
  const bitpacker::reserved m_padding27;
  ClipInfo mClipInfo;
  size_t  mpad1_size;
  bitpacker::array<bitpacker::uint> mpad1;

  		size_t & pad1_cb(void)
  		{
  			mpad1_size = mSequenceInfo_start_address ? mSequenceInfo_start_address - byteOffset(&mpad1) : 0;
  			return mpad1_size;
  		}
  	
  mutable SequenceInfo mSequenceInfo;
  size_t  mpad2_size;
  bitpacker::array<bitpacker::uint> mpad2;

  		size_t & pad2_cb(void)
  		{
  			mpad2_size = mProgramInfo_start_address ? mProgramInfo_start_address - byteOffset(&mpad2) : 0;
  			return mpad2_size;
  		}
  	
  mutable ProgramInfo mProgramInfo;
  size_t  mpad3_size;
  bitpacker::array<bitpacker::uint> mpad3;

  		size_t & pad3_cb(void)
  		{
  			mpad3_size = mCPI_start_address ? mCPI_start_address - byteOffset(&mpad3) : 0;
  			return mpad3_size;
  		}
  	
  mutable CPI mCPI;
  size_t  mpad4_size;
  bitpacker::array<bitpacker::uint> mpad4;

  		size_t & pad4_cb(void)
  		{
  			mpad4_size = mClipMark_start_address ? mClipMark_start_address - byteOffset(&mpad4) : 0;
  			return mpad4_size;
  		}
  	
  mutable ClipMark mClipMark;
  size_t  mpad5_size;
  bitpacker::array<bitpacker::uint> mpad5;

  		size_t & pad5_cb(void)
  		{
  			mpad5_size = mExtensionData_start_address ? mExtensionData_start_address - byteOffset(&mpad5) : 0;
  			return mpad5_size;
  		}
  	
  ExtensionData mExtensionData;
  UInt32  mbdrom_version;

  		UInt32 bdrom_ver()
  		{
  			if (mversion_number == "0100")
  				mbdrom_version = 0x0100;
  			else if (mversion_number == "0200")
  				mbdrom_version = 0x0200;
  			else
  				mbdrom_version = 0x0090;
  			return mbdrom_version;
  		}
  	

  ClipInfo_clpi();
  ClipInfo_clpi(const ClipInfo_clpi& _a);
  explicit 
  ClipInfo_clpi(const char* _a);
  ClipInfo_clpi(rt_stream& _a);
  virtual ~ClipInfo_clpi() {}
  void layout(size_t = 0);
  void init();
  void copy(const ClipInfo_clpi& _a);
  ClipInfo_clpi& operator=(const ClipInfo_clpi& _a);
  virtual void resizeEvent(size_t _selector, size_t _newSize);
  void addOffset(size_t& _a) const;
  bool bitOffset(size_t& _offset, const bitpacker::BitField* _field) const;
  void pack(bitpacker::BitPtr& _a) const;
  void bind(bitpacker::ConstBitPtr& _a);
  void read(rt_stream& _is, size_t& _offset);
  void refresh();
  void validate(rt_stream& _os) const;
  #ifdef BITPACKER_ENABLE_PRINT
  void print(rt_stream& _os, int _indent) const;
  #endif
};

}
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ClipMark& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ISRC& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::video_format_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::audio_format_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::PG_format_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::IG_format_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::textST_format_table& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::StreamCodingInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::StreamInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::program_sequence& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ProgramInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::SequenceInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::SequenceInfo::ATC_sequence& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::SequenceInfo::ATC_sequence::STC_sequence& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::TS_type_info_block& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ATC_delta_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::font_files& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ClipInfo& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::HDMV_LPCM_down_mix_coefficient_entry& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::HDMV_LPCM_down_mix_coefficient& _a);
#endif
#ifdef BITPACKER_ENABLE_PRINT
rt_stream& operator<<(rt_stream& _os, const BDROM::ClipInfo_clpi& _a);
#endif

#if defined(_WIN32)
#pragma warning(pop)
#endif

#endif // _BDROMClipInfo_h_

